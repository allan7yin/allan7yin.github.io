### System Call Interface

Remeber, user-level applications must make `system_calls` (usually, API’s built on top of system call interface, makes development easier) to the kernel to interact with the kernel. In general:

![[Screenshot_2023-10-29_at_1.23.38_PM.png]]

- The application calls a library wrapper function
- This function executes the `syscall` function, which traps to the kernel
- which then completes the task
- returns to the wrapper function
- which returns to the application page

  

**System Calls** are the API that programmers use to interact with the operating system.

- Applications invoke system calls
    - recall the examples we’ve seen: `fork()`, `waitpid()`, `open()`, `close()`, …
- The system call interface can also have some very complex calls
    - `sysctl()` exposes operating system configuration
    - `ioctl()` controlling devices
- _**Key Requirement →**_ we need a mechanism to safelty enter and exit the kernel
    - applications do **not** call kernel functions directly

  

Recall that we’ve seen there are 2 different modes: **(1) Kernel/Privileged Mode** for the OS **(2) User Mode** for applications

- **kernel mode** can _access privileged processor features_
    - can access all restricted processor instructions and registers
    - can enable and disable interrupts, setup interupt handlers
    - constrols the system call interface
    - can modify the TLB (virtual memory … future lecture)
    - can interact directly with peripherals (e.g mouse, keyboard, monitor, Wi-Fi card)
- kernel mode allows the kernel to _**protect itslef and isolate processes from each other**_
    - processes cannot read or write kernel memory
    - pocesses cannot directly call kernel functions

  

So, we know that in order for user-level applications to interact with the kernel, we do so through the **system call interface**. Once we do make a system call, how does the OS handle the transition from user space to kernel space, and vice versa?

---

### Mode Transitions

**Kernel mode** can only be entered through well defined entry points. There are **2** classes of entry points that are provided by the processor:

- `**Interrupts**`
    - these are _generated by the devices to signal that they need attention_
        - e.g keyboard input is ready, a packet has arrived from the internet
    - will see more of this in IO in the future
- `**Exceptions**`
    - exceptions are _conditions discovered by the processor while executing an instruction_
    - e.g. divide by zero, page faults, internal processor errors
- Interrupts and exceptions cause the processor to **_transfer control_** _to the_ **_interrupt/exception handler_**_,_ which occurs a fixed entry point (i.e. address) in the kernel

  

**→ Interrupts**

Interrupts are _**raised by devices needing attention.**_ The **interrupt handler** is a function in the kernel that services a device request. Here is what the interrupt process looks like:

- The device signals the processor through a physical pin or bus message (e.g change the value on the line from 0 to 1)
- The processor interrupts the execution of the current running program
- It begins executing the interrupt handler in privileged mode

**Most** interrupts can be disabled, but not all. These are called → ==**Non-maskable interrupts (NMI)**== are for urgent system requests, e.g. processor is overheating

  

**→ Exceptions**

- **Exceptions (or faults)** are _conditions encountered during execution of a program_
- Exceptions are due to multiple reasons:
    - **program errors:** divide by 0, illegal instructions, unaligned memory access, etc.
    - **operating system requests:** Page faults (i.e page not in RAM)
    - **hardware errors:** system check (bad memory or internal CPU failures)
- **Processors** _handle exceptions similar to interrupts_
    - the processor stops at the instruction that triggered the exception (usually)
    - control is transferred to a fixed location where the exception handler is located and starts executing in kernel mode
- ==**System calls are a class of exceptions!**==

---

### **x86-64 Exception Vectors**

_Interrupts, exceptions and system calls use the same mechanism_ to trap into the kernel, which are the exception vectors. These are locations in memory where the processor jumps to handle specific types of exceptions or interrupts. These vectors are typically organized in a table known as the **interrupt Descriptor Table (IDT)** which we will see later on.

```C++
\#define      T_DE       0        /* Divide Error Exception */
\#define      T_DB       1        /* Debug Exception */
\#define      T_NMI      2        /* NMI Interrupt -> Non-Maskable Interrupt */
\#define      T_BP       3        /* Breakpoint Exception */
\#define      T_OF       4        /* Overflow Exception */
\#define      T_BR       5        /* BOUND Range Exceeded Exception */
\#define      T_UD       6        /* Invalid Opcode Exception */
\#define      T_NM       7        /* Device Not Available Exception */
\#define      T_DF       8        /* Double Fault Exception */
\#define      T_TS      10        /* Invalid TSS Exception */
\#define      T_NP      11        /* Segment Not Present */
\#define      T_SS      12        /* Stack Fault Exception */
\#define      T_GP      13        /* General Protection Exception */
\#define      T_PF      14        /* Page-Fault Exception */
\#define      T_MF      16        /* x87 FPU Floating-Point Error */
\#define      T_AC      17        /* Alignment Check Exception */
\#define      T_MC      18        /* Machine-Check Exception */
```

The following will explain the non-obvious ones from above:

1. `**T_DE**` **(Divide Error Exception - Vector 0):**
    - This exception occurs when the DIV or IDIV instruction is executed with a divisor of 0.
2. `**T_DB**` **(Debug Exception - Vector 1):**
    - This exception is often used for debugging purposes. It can be triggered by breakpoints or other debugging-related events.
3. `**T_NMI**` **(Non-Maskable Interrupt - Vector 2):**
    - NMI stands for Non-Maskable Interrupt. This is a hardware interrupt that cannot be ignored or disabled by software. It usually indicates a serious and non-recoverable error.
4. `**T_BP**` **(Breakpoint Exception - Vector 3):**
    - This exception is triggered by the INT3 instruction and is commonly used for implementing software breakpoints in debugging scenarios.
5. `**T_OF**` **(Overflow Exception - Vector 4):**
    - This exception occurs when an arithmetic operation results in a value too large to be represented in the available number of bits.
6. `**T_BR**` **(BOUND Range Exceeded Exception - Vector 5):**
    - This exception is generated when the BOUND instruction detects that an array index is out of bounds.
7. `**T_UD**` **(Invalid Opcode Exception - Vector 6):**
    - This exception occurs when the processor encounters an invalid or undefined opcode.
8. `**T_NM**` **(Device Not Available Exception - Vector 7):**
    - This exception is raised when a device becomes unavailable during an FPU (Floating Point Unit) operation.
9. `**T_DF**` **(Double Fault Exception - Vector 8):**
    - This exception occurs when an exception is triggered while the CPU is already processing an exception.
10. `**T_TS**` **(Invalid TSS Exception - Vector 10):**
    - This exception is generated when a task switch involves an invalid Task State Segment.
11. `**T_NP**` **(Segment Not Present - Vector 11):**
    - This exception occurs when a segment selector references a segment that is not present in memory.
12. `**T_SS**` **(Stack Fault Exception - Vector 12):**
    - This exception is triggered when a stack-related operation (such as a push or pop) encounters an error.
13. `**T_GP**` **(General Protection Exception - Vector 13):**
    - This is a catch-all exception for various protection violations, such as accessing restricted memory.
14. `**T_PF**` **(Page-Fault Exception - Vector 14):**
    - Generated when there is a page-level protection violation or a page is not present in memory.
15. `**T_MF**` **(x87 FPU Floating-Point Error - Vector 16):**
    - This exception is related to errors in the x87 FPU (Floating Point Unit) operations.
16. `**T_AC**` **(Alignment Check Exception - Vector 17):**
    - This exception occurs when an unaligned memory access is attempted in a context where alignment checking is enabled.
17. `**T_MC**` **(Machine-Check Exception - Vector 18):**
    
    - This is used for reporting hardware errors that cannot be corrected by the operating system.
    
      
    

**→ System Calls**

System calls are performed by using the **`T_SYS`** exception vector

1. The application loads the system call arguments into the appropriate registers
2. In particular, it then loads the system call number into register **`rdi`** (first arg) **→ system call numbers shown below**
3. Executes the **`int 60`** instruction, where **`int`** is the assembly language instruction to generate an interrupt and 60 corresponds to **`T_SYS`**, the system call exception
4. The processor looks up the interrupt vector (in this case 60) in a table (associating the interrupt to an address) and jumps to that address (in this case, the kernel exception handler)
5. When done, the processor returns to userspace and user mode using the **`iret`** instruction, return from interrupt instruction

  

In reference to the above, here are the system call numbers defined for **CastorOS:**

```C++
\#define SYSCALL_NULL       0x00  /* Null System Call */
\#define SYSCALL_TIME       0x01  /* Get System Time */
\#define SYSCALL_GETPID     0x02  /* Get Process ID */
\#define SYSCALL_EXIT       0x03  /* Exit Process */
\#define SYSCALL_SPAWN      0x04  /* Spawn a New Process */
\#define SYSCALL_WAIT       0x05  /* Wait for Child Process */

// Memory
\#define SYSCALL_MMAP       0x08  /* Memory Map */
\#define SYSCALL_MUNMAP     0x09  /* Memory Unmap */
\#define SYSCALL_MPROTECT   0x0A  /* Memory Protection Operation */
// ...
```

1. **Process Management:**
    - `**SYSCALL_NULL (0x00)**`: This is likely a placeholder or a no-operation (NOP) system call, often used for testing or as a placeholder in system call tables.
    - `**SYSCALL_TIME (0x01)**`: Retrieves the current system time.
    - `**SYSCALL_GETPID (0x02)**`: Gets the Process ID of the calling process.
    - `**SYSCALL_EXIT (0x03)**`: Exits the current process.
2. **Process Creation and Synchronization:**
    - `**SYSCALL_SPAWN (0x04)**`: Spawns a new process.
    - `**SYSCALL_WAIT (0x05)**`: Waits for a child process to terminate.
3. **Memory Management:**
    - `**SYSCALL_MMAP (0x08)**`: Memory mapping system call, likely used for allocating memory and mapping it to a process's address space.
    - `**SYSCALL_MUNMAP (0x09)**`: Unmaps previously mapped memory, freeing up resources.
    - `**SYSCALL_MPROTECT (0x0A)**`: Sets the protection on a region of memory, controlling its access permissions.

  

We previously mentioned that the the **interrupt descriptor table (IDT)** defines the entry point (address to jump to) for a particular interrupt vector i.e for a vector interrupt `60`, the entry point can be found at **`IDT[60]`****.**

- This table handles both interrupts and exceptions in x86-64 architecture and serves as a dispatch table mapping interrupt or exception numbers to the corresponding handler addresses
- The OS initializes the **IDT** with entry points for up to **256** interrupts (i.e interrupt vectors **0-255**). Each one is called an **Interrupt Gate Descriptor**. Here is what such a **interrupt gate descriptor** looks like:

![[Screenshot_2023-10-30_at_1.07.45_PM.png]]

- Here is what each of the components of the gate are:
    - **Target Offset:** this is the address of the first instruction (entry point) of the interrupt handler
    - **Target Selector:** sets privilege level (user/kernel mode) → we will see more on this later
    - **P:** Present. This is a 1-bit field that indicates whether the interrupt gate is present (P=1) or not (P=0). If the gate is not present, attempting to use it will cause a general protection fault.
    - **Descriptor Privilege Level (DPL):** Minimum **privilege** level that can trigger this interrupt or exception handler
        - For example, a DPL of 0 means that the gate can be executed from ring 0 (kernel mode), while a DPL of 3 means it can be executed from any privilege level.
    - **Type:** Identifies this as a 64-bit IDT entry (as opposed to other types of entries)
    - **IST (Interrupt Stack Table):** specifies the index into the **Interrupt Stack Table →** This is a value (0-7) as there are only 8 kernel stacks. This value indiciates which kernel stack to use.

  

**→ Configuring Interrupt Handling (x86–64)  
  
**

1. The OS initializes the IDT with entry points for up to 256 points
2. The OS initializes the IDT base address and length (i.e limit) of the IDT
3. The OS executes the `lidt` (load interrupt descriptor table) instruction to load the address and size of the IDT into a special register called the Interrupt Descriptor Table Register (IDTR). This register is used by the processor to locate the IDT when handling interrupts and exceptions.

  

**→ Hardware Interrupt Handling Process (x86-64)**

1. Find the **IDT** (interrupt descriptor table) through **IDTR** (resgiter)
2. Reads the **IDT** entry for that for that particular interrupt vector (say `60` for `syscall`)
3. The **IST** field of the entry specifies which stack to use (0-7)
4. **Looks up the kernel stack location** in the TSS (Task State Segment) which provides infomration about a particualr task (i.e process or thread)
    1. each one has such a segment
5. CPU **pushes the interrupt stack frame** onto this kernel stack
6. Then, the kernel pushes the **trap frame**
    1. represents a data structure or a set of registers that captures the state of the processor at the time of the interrupt or exception. The trap frame is pushed onto the kernel stack, and it contains information needed to resume the interrupted execution after the interrupt or exception has been handled
    2. **look into difference with interrupt stack frame when you have time**
7. Then it **sets up the CPU** to known state to run C code

  

So, how would this look in CastorOS?

![[Screenshot_2023-10-30_at_3.04.48_PM.png]]

So, lets go into detail on how system call operations work. Say an application called into the `C` library, like `write()`.

- library executes the `syscall` function
- _**kernel exception handler runs**_
    - switch the corresponding kernel stack
    - create a _trap frame_ which contains the program state
    - determine the type of execution (in this case `syscall`)
    - determine the type of system call (e.g `SYSCALL_WRITE`)
    - run the function in the kernel (e.g `sys_write()`)
    - restore the application state from the trap frame
    - return from exception (`iret` instruction)
- library wrapper function returns to the application

  

### How are values passed?

**Application Binary Interface (ABI)** defines the contract between an application’s functions and system calls (or more generally between any two machine code modules). It standardizes how parameters are passed, how functions are called, and how values are returned.